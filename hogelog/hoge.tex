% -*- coding: utf-8 -*-
%!TEX root = ../book.tex

\cleardoublepage
\plainifnotempty

\chapter{とある世界で一番高速なBrainf*ck処理系}
\begin{flushright}
hogelog
\end{flushright}

\section{まえがき}
\lettrine{世}
の中にはたくさんのプログラミング言語が存在する。
そしてたくさんのプログラミング言語処理系が存在する。
例えばRuby言語には
Matzによるオリジナル実装を元にした
MRI\footnote{http://www.ruby-lang.org/ja/}、
JVM上で動作する
JRuby\footnote{http://jruby.org/}、
JITコンパイラや世代別GCなどが組み込まれた
Rubinius\footnote{http://rubini.us/}、
組み込みスクリプトエンジン向けとして作られた
mruby\footnote{https://github.com/mruby/mruby/}
など様々な処理系がある。
例えば大規模分散処理のためHadoopフレームワークを利用したければ
JRubyを使うこともあるだろう、
エディタアプリケーションにスクリプト機能を組み込むためにはmrubyを
使うかもしれない。
効率の良いメモリ管理システム・
堅牢な例外処理機構・
ビルドの簡単さなど
言語処理系にとって重要な機能は
挙げればキリがないですけど
まあ
{\LARGE \textbf{とりあえず処理系が高速であるにこしたことはないでしょう？}}

Brainf*ck
\footnote{http://www.kmonos.net/alang/etc/brainfuck.php とかわかりやすい紹介です}
というとてもすごく超オモシロかっこいい言語があるのですが
どの処理系を使えばいいのかわからなかったのでとりあえず自分で
世界最速の処理系を作ってやったぜ、と書こうかと思いましたがやめました。
ここではBrainf*ckの「処理系の実装が容易である」という特徴に着目します。
というわけでBrainf*ckの処理系をお題として言語処理系の高速化に
取り組んでみましょう。
とりあえずの目標はこの記事のタイトル通りに
{\LARGE \textbf{「世界で一番高速なBrainf*ck処理系」}}
ということにしましょう。

なんかこんなかんじ。

\section{高速化手法}
まあなんか色々する。

\subsection{direct threading}
ruby maniacs紹介程度で済ませていいんじゃないかな。

\subsection{JITコンパイル}
Xbyak\footnote{http://homepage1.nifty.com/herumi/soft/xbyak.html}
とか。

\subsection{最適化}
いろんなパターンを紹介。

なぁに、まだ5日もあるさ。

